{"version":3,"sources":["algorithms/aStar.ts","algorithms/randomMaze.ts","algorithms/recursiveMaze.ts","components/svg/Reset.tsx","components/Button.tsx","components/InputLabel.tsx","components/svg/Play.tsx","components/Dropdown.tsx","components/svg/Start.tsx","components/svg/Target.tsx","components/Node.tsx","components/Pathfinder.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["aStar","grid","startNode","targetNode","diagonal","openNodes","closedNodes","length","currentNode","currentIndex","nodeIndex","f","parseInt","splice","push","rowIdx","colIdx","current","path","parent","reverse","moves","neighbours","move","newRowIdx","newColIdx","isWall","isTarget","neighbour","valid_neighbour","closedNode","openNode","g","h","undefined","getRandom","arr","n","walls","i","index","Math","floor","random","randomElement","randomMaze","grid_rows","grid_cols","totalWalls","availableGridPositions","j","removeWall","indexOf","shuffle","recursiveMaze","startRowIdx","startColIdx","fillWalls","row","node","potentialMove","pop","linkNodeRowIdx","linkNodeColIdx","SReset","styled","svg","props","fill","css","Reset","className","width","height","viewBox","d","SButton","button","disabled","SButtonText","span","Button","children","onClick","SLabel","label","InputLabel","htmlFor","SPlay","Play","SDiv","div","SDropdown","SCircle","SList","ul","SListItem","li","Dropdown","options","selectedOption","setSelectedOption","React","selected","setSelected","map","option","value","handleItemClick","SStart","Start","STarget","Target","Node","onMouseDown","onMouseEnter","onMouseUp","isStart","isPath","isVisited","INIT_START_NODE","INIT_TARGET_NODE","SButtonWrapper","SNoPathText","SGrid","table","getInitialGrid","columns","rows","startPosition","targetPosition","currentRow","col","createNode","clearGrid","includeWalls","newGrid","Pathfinder","useState","setStartNode","setTargetNode","setGrid","mouseDown","setMouseDown","movingStart","setMovingStart","movingTarget","setMovingTarget","noValidPath","setNoValidPath","animating","setAnimating","callRecMaze","setCallRecMaze","mazeType","setMazeType","algoType","setAlgoType","handleMouseUp","timer","delay","Promise","resolve","setTimeout","handleAStar","a","handleRandomMaze","count","wall","handleRecursiveMaze","split","r","c","useEffect","nodeIdx","start","target","handleMouseDown","handleMouseEnter","SContainer","SHeader","h1","SDescription","p","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ecbf449a.chunk.js","sourcesContent":["import { INode } from \"../types\";\n\nconst aStar = (\n  grid: INode[][],\n  startNode: INode,\n  targetNode: INode,\n  diagonal = false\n) => {\n  const openNodes: INode[] = [startNode];\n  const closedNodes: INode[] = [];\n\n  while (openNodes.length > 0) {\n    let currentNode = openNodes[0];\n    let currentIndex = 0;\n    for (const nodeIndex in openNodes) {\n      if (openNodes[nodeIndex].f < currentNode.f) {\n        currentNode = openNodes[nodeIndex];\n        currentIndex = parseInt(nodeIndex);\n      }\n    }\n\n    // remove node with lowest f score and add to closed list\n    openNodes.splice(currentIndex, 1);\n    closedNodes.push(currentNode);\n\n    // If current has reached the target\n    if (\n      currentNode.rowIdx === targetNode.rowIdx &&\n      currentNode.colIdx === targetNode.colIdx\n    ) {\n      let current: INode | undefined = currentNode;\n      const path = [];\n      while (current) {\n        path.push(current);\n        current = current.parent;\n      }\n\n      return { path: path.reverse(), closedNodes };\n    }\n\n    const moves = diagonal\n      ? [\n          [-1, -1],\n          [-1, 0],\n          [-1, 1],\n          [0, 1],\n          [1, 1],\n          [1, 0],\n          [1, -1],\n          [0, -1],\n        ]\n      : [\n          [-1, 0],\n          [0, 1],\n          [1, 0],\n          [0, -1],\n        ];\n\n    // Generate neighbours\n    const neighbours = [];\n    for (const move of moves) {\n      const newRowIdx = currentNode.rowIdx + move[0];\n      const newColIdx = currentNode.colIdx + move[1];\n\n      // new node in grid and not a wall\n      if (\n        newRowIdx > -1 &&\n        newRowIdx < grid.length &&\n        newColIdx > -1 &&\n        newColIdx < grid[0].length &&\n        (!grid[newRowIdx][newColIdx].isWall ||\n          grid[newRowIdx][newColIdx].isTarget)\n      ) {\n        // ensure legal move (i.e. no diagonal through walls)\n        if (\n          (move[0] === -1 &&\n            move[1] === -1 &&\n            grid[newRowIdx][newColIdx + 1].isWall &&\n            grid[newRowIdx + 1][newColIdx].isWall) ||\n          (move[0] === -1 &&\n            move[1] === 1 &&\n            grid[newRowIdx][newColIdx - 1].isWall &&\n            grid[newRowIdx + 1][newColIdx].isWall) ||\n          (move[0] === 1 &&\n            move[1] === 1 &&\n            grid[newRowIdx - 1][newColIdx].isWall &&\n            grid[newRowIdx][newColIdx - 1].isWall) ||\n          (move[0] === 1 &&\n            move[1] === -1 &&\n            grid[newRowIdx - 1][newColIdx].isWall &&\n            grid[newRowIdx][newColIdx + 1].isWall)\n        ) {\n          continue;\n        } else {\n          neighbours.push(grid[newRowIdx][newColIdx]);\n        }\n      }\n    }\n\n    // loop through neighbours\n    for (const neighbour of neighbours) {\n      let valid_neighbour = true;\n      for (const closedNode of closedNodes) {\n        if (\n          closedNode.rowIdx === neighbour.rowIdx &&\n          closedNode.colIdx === neighbour.colIdx\n        ) {\n          valid_neighbour = false;\n        }\n      }\n\n      for (const openNode of openNodes) {\n        if (\n          openNode.rowIdx === neighbour.rowIdx &&\n          openNode.colIdx === neighbour.colIdx\n        ) {\n          valid_neighbour = false;\n        }\n      }\n\n      if (valid_neighbour) {\n        neighbour.g = currentNode.g + 1;\n        neighbour.h =\n          (neighbour.rowIdx - targetNode.rowIdx) ** 2 +\n          (neighbour.colIdx - targetNode.colIdx) ** 2;\n        neighbour.f = neighbour.g + neighbour.h;\n        neighbour.parent = currentNode;\n\n        openNodes.push(neighbour);\n      }\n    }\n  }\n\n  return { path: undefined, openNodes: undefined };\n};\n\nexport default aStar;\n","import { INode } from \"../types\";\n\nconst randomMaze = (\n  startNode: INode,\n  targetNode: INode,\n  grid_rows: number,\n  grid_cols: number\n) => {\n  const nodes = grid_rows * grid_cols - 2;\n  const gridCovered = 0.3;\n  const totalWalls = nodes * gridCovered;\n\n  const availableGridPositions = [];\n  for (let i = 0; i < grid_rows; i++) {\n    for (let j = 0; j < grid_cols; j++) {\n      if (\n        (i === startNode.rowIdx && j === startNode.colIdx) ||\n        (i === targetNode.rowIdx && j === targetNode.colIdx)\n      ) {\n        continue;\n      } else {\n        availableGridPositions.push([i, j]);\n      }\n    }\n  }\n\n  const walls = getRandom(availableGridPositions, totalWalls);\n\n  return walls;\n};\n\nconst getRandom = (arr: number[][], n: number) => {\n  const walls = [];\n  for (let i = 0; i < n; i++) {\n    const index = Math.floor(Math.random() * arr.length);\n    const randomElement = arr[index];\n    walls.push(randomElement);\n    arr.splice(index, 1);\n  }\n\n  return walls;\n};\n\nexport default randomMaze;\n","import { INode } from \"../types\";\n\nexport const walls: string[] = [];\n\nconst recursiveMaze = (\n  grid: INode[][],\n  startRowIdx: number,\n  startColIdx: number,\n  fillWalls: boolean\n) => {\n  // Fill Grid with walls\n  if (fillWalls) {\n    for (const row of grid) {\n      for (const node of row) {\n        node.isWall = true;\n        walls.push(`${node.rowIdx}.${node.colIdx}`);\n      }\n    }\n  }\n\n  grid[startRowIdx][startColIdx].isWall = false;\n  removeWall(startRowIdx, startColIdx);\n\n  let moves = [\n    [-1, 0],\n    [0, 1],\n    [1, 0],\n    [0, -1],\n  ];\n  moves = shuffle(moves);\n\n  while (moves.length > 0) {\n    const potentialMove = moves.pop();\n    // calculate the new node's coordinates using our random direction.\n    // we *2 as we are moving two cells in each direction to the next node\n    const newRowIdx = startRowIdx + potentialMove![0] * 2;\n    const newColIdx = startColIdx + potentialMove![1] * 2;\n\n    if (\n      newRowIdx > -1 &&\n      newRowIdx < grid.length &&\n      newColIdx > -1 &&\n      newColIdx < grid[0].length &&\n      grid[newRowIdx][newColIdx].isWall\n    ) {\n      const linkNodeRowIdx = startRowIdx + potentialMove![0];\n      const linkNodeColIdx = startColIdx + potentialMove![1];\n      grid[linkNodeRowIdx][linkNodeColIdx].isWall = false;\n      removeWall(linkNodeRowIdx, linkNodeColIdx);\n\n      recursiveMaze(grid, newRowIdx, newColIdx, false);\n    }\n  }\n};\n\nconst removeWall = (rowIdx: number, colIdx: number) => {\n  const index = walls.indexOf(`${rowIdx}.${colIdx}`);\n  walls.splice(index, 1);\n};\n\nconst shuffle = (arr: number[][]) => {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n};\n\nexport default recursiveMaze;\n","import * as React from \"react\";\nimport styled, { css } from \"styled-components\";\n\ninterface IProps {\n  className?: string;\n  fill?: string;\n}\n\nconst SReset = styled.svg<IProps>`\n  ${(props) =>\n    props.fill &&\n    css`\n      fill: ${props.fill};\n    `}\n`;\n\nconst Reset = ({ className, fill }: IProps) => {\n  return (\n    <SReset\n      className={className}\n      fill={fill}\n      width=\"20\"\n      height=\"20\"\n      viewBox=\"0 0 28.265 28.265\"\n    >\n      <path\n        d=\"M14.133,28.265c-7.061,0-12.805-5.75-12.805-12.809c0-7.06,5.744-12.807,12.805-12.807c0.469,0,0.943,0.027,1.414,0.08\n\t\tv-2.07c0-0.266,0.164-0.508,0.406-0.611c0.252-0.098,0.531-0.043,0.723,0.148l4.537,4.547c0.258,0.258,0.258,0.67,0,0.932\n\t\tl-4.535,4.557c-0.193,0.188-0.473,0.246-0.725,0.143c-0.242-0.104-0.406-0.344-0.406-0.609V7.47\n\t\tc-0.469-0.086-0.941-0.125-1.414-0.125c-4.473,0-8.113,3.639-8.113,8.111c0,4.471,3.641,8.113,8.113,8.113s8.111-3.643,8.111-8.113\n\t\tc0-0.363,0.295-0.66,0.662-0.66h3.369c0.365,0,0.662,0.297,0.662,0.66C26.937,22.515,21.189,28.265,14.133,28.265z\"\n      />\n    </SReset>\n  );\n};\n\nexport default Reset;\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport Reset from \"./svg/Reset\";\n\ninterface IStyleProps {\n  disabled?: boolean;\n}\n\nconst SButton = styled.button<IStyleProps>`\n  display: flex;\n  align-items: center;\n  color: ${(props) => (props.disabled ? \"#c0abff\" : \"white\")};\n  background-color: #5627df;\n  border-radius: 10px;\n  border: none;\n  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.1);\n  cursor: ${(props) => (props.disabled ? \"unset\" : \"pointer\")};\n  height: 50px;\n  padding: 10px 20px 10px 20px;\n\n  :focus {\n    outline: none;\n  }\n`;\n\nconst SButtonText = styled.span`\n  font-family: \"Poppins\", sans-serif;\n  font-size: 16px;\n  font-weight: 500;\n`;\n\nconst SReset = styled(Reset)`\n  margin-left: 10px;\n`;\n\ninterface IProps extends IStyleProps {\n  children: React.ReactNode;\n  onClick: () => void;\n}\n\nconst Button = ({ children, onClick, disabled }: IProps) => (\n  <SButton onClick={onClick} disabled={disabled}>\n    <SButtonText>{children}</SButtonText>\n    <SReset fill={disabled ? \"#c0abff\" : \"white\"} />\n  </SButton>\n);\n\nexport default Button;\n","import * as React from \"react\";\nimport styled from \"styled-components\";\n\nconst SLabel = styled.label`\n  color: #5627df;\n  font-size: 12px;\n  line-height: 11px;\n  font-weight: 500;\n  transform: translateY(-8px);\n  left: 19px;\n  pointer-events: none;\n  position: absolute;\n  top: 16px;\n  transition: 0.2s ease all;\n`;\n\ninterface IProps {\n  children?: React.ReactNode;\n  htmlFor?: string;\n}\n\nconst InputLabel = ({ children, htmlFor }: IProps) => {\n  return <SLabel htmlFor={htmlFor}>{children}</SLabel>;\n};\n\nexport default InputLabel;\n","import * as React from \"react\";\nimport styled, { css } from \"styled-components\";\n\ninterface IProps {\n  className?: string;\n  fill?: string;\n}\n\nconst SPlay = styled.svg<IProps>`\n  ${(props) =>\n    props.fill &&\n    css`\n      fill: ${props.fill};\n    `}\n`;\n\nconst Play = ({ className, fill }: IProps) => {\n  return (\n    <SPlay\n      className={className}\n      fill={fill}\n      width=\"15\"\n      height=\"15\"\n      viewBox=\"0 0 163.861 163.861\"\n    >\n      <g>\n        <path\n          d=\"M34.857,3.613C20.084-4.861,8.107,2.081,8.107,19.106v125.637c0,17.042,11.977,23.975,26.75,15.509L144.67,97.275\n\t\tc14.778-8.477,14.778-22.211,0-30.686L34.857,3.613z\"\n        />\n      </g>\n    </SPlay>\n  );\n};\n\nexport default Play;\n","import * as React from \"react\";\nimport styled, { css } from \"styled-components\";\n\nimport InputLabel from \"./InputLabel\";\nimport Play from \"./svg/Play\";\n\ninterface IStyleProps {\n  disabled: boolean;\n}\n\ninterface IProps extends IStyleProps {\n  label?: string;\n  options: string[];\n  selectedOption: string;\n  setSelectedOption: (option: string) => void;\n  onClick: () => void;\n}\n\nconst SDiv = styled.div`\n  align-items: center;\n  display: inline-flex;\n  margin-left: 36px;\n  position: relative;\n  width: 200px;\n`;\n\nconst SDropdown = styled.div<IStyleProps>`\n  align-items: center;\n  display: flex;\n  cursor: ${(props) => (props.disabled ? \"default\" : \"pointer\")};\n  background-color: #f5f0ff;\n  border: solid 1px #5627df;\n  border-radius: 10px;\n  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.1);\n  background-image: linear-gradient(45deg, transparent 50%, #5627df 50%),\n    linear-gradient(135deg, #5627df 50%, transparent 50%);\n  background-position: calc(100% - 20px) calc(1em + 5px),\n    calc(100% - 15px) calc(1em + 5px), 100% 0;\n  background-size: 5px 5px, 5px 5px, 2.5em 2.5em;\n  background-repeat: no-repeat;\n  font-family: \"Poppins\", sans-serif;\n  font-size: 16px;\n  height: 35px;\n  padding: 12px 0 0 18px;\n  width: 100%;\n  user-select: none;\n\n  :focus {\n    outline: none;\n  }\n`;\n\nconst SCircle = styled.div<IStyleProps>`\n  display: flex;\n  align-items: center;\n  position: absolute;\n  left: -20%;\n  z-index: 1;\n  border: 5px solid #fdf9fb;\n  background-color: #5627df;\n  border-radius: 50%;\n  cursor: ${(props) => (props.disabled ? \"default\" : \"pointer\")};\n  height: 45px;\n  justify-content: center;\n  line-height: 45px;\n  text-align: center;\n  width: 45px;\n\n  :hover {\n    ${(props) =>\n      !props.disabled &&\n      css`\n        border: 5px solid #5628df;\n      `}\n  }\n`;\n\nconst SList = styled.ul`\n  background-color: white;\n  border-radius: 10px;\n  box-shadow: 0 3px 6px 0 rgba(0, 0, 0, 0.1);\n  list-style-type: none;\n  margin: 0;\n  max-height: 150px;\n  overflow: auto;\n  padding: 0;\n  position: absolute;\n  text-align: left;\n  width: 100%;\n  top: 49px;\n  z-index: 1;\n\n  & > *:last-child {\n    border-bottom: none;\n  }\n`;\n\nconst SListItem = styled.li`\n  align-items: center;\n  border-bottom: 1px solid #efefef;\n  cursor: pointer;\n  display: flex;\n  height: 40px;\n  padding-left: 18px;\n  user-select: none;\n\n  :hover {\n    background-color: #f5f0ff;\n  }\n`;\n\nconst Dropdown = ({\n  label,\n  options,\n  selectedOption,\n  setSelectedOption,\n  onClick,\n  disabled,\n}: IProps) => {\n  const [selected, setSelected] = React.useState(true);\n\n  React.useEffect(() => {\n    setSelected(true);\n  }, [disabled]);\n\n  const handleItemClick = (option: string) => {\n    if (option !== selectedOption) {\n      setSelectedOption(option);\n    }\n    setSelected(true);\n  };\n\n  return (\n    <SDiv>\n      <SCircle\n        disabled={disabled}\n        onClick={\n          disabled\n            ? () => {\n                return;\n              }\n            : onClick\n        }\n      >\n        <Play fill={disabled ? \"#c0abff\" : \"white\"} />\n      </SCircle>\n      <SDropdown\n        onClick={() =>\n          disabled\n            ? () => {\n                return;\n              }\n            : setSelected(!selected)\n        }\n        disabled={disabled}\n      >\n        {selectedOption}\n      </SDropdown>\n      {!selected && (\n        <SList>\n          {options.map((option: string, index: number) => (\n            <SListItem\n              key={index}\n              value={option}\n              onClick={() => handleItemClick(option)}\n            >\n              {option}\n            </SListItem>\n          ))}\n        </SList>\n      )}\n      <InputLabel>{label}</InputLabel>\n    </SDiv>\n  );\n};\n\nexport default Dropdown;\n","import * as React from \"react\";\nimport styled, { css } from \"styled-components\";\n\ninterface IProps {\n  className?: string;\n  fill?: string;\n}\n\nconst SStart = styled.svg<IProps>`\n  ${(props) =>\n    props.fill &&\n    css`\n      fill: ${props.fill};\n    `}\n`;\n\nconst Start = ({ className, fill }: IProps) => {\n  return (\n    <SStart\n      className={className}\n      fill={fill}\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 16 16\"\n    >\n      <path d=\"M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM6 12v-8l6 4-6 4z\"></path>\n    </SStart>\n  );\n};\n\nexport default Start;\n","import * as React from \"react\";\nimport styled, { css } from \"styled-components\";\n\ninterface IProps {\n  className?: string;\n  fill?: string;\n}\n\nconst STarget = styled.svg<IProps>`\n  ${(props) =>\n    props.fill &&\n    css`\n      fill: ${props.fill};\n    `}\n`;\n\nconst Target = ({ className, fill }: IProps) => {\n  return (\n    <STarget\n      className={className}\n      fill={fill}\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 512 512\"\n    >\n      <g>\n        <g>\n          <path\n            d=\"M266.8,245.685c-0.084-0.088-0.108-0.205-0.194-0.291l-85.604-85.605v-53.789c0-3.985-1.582-7.793-4.394-10.606\n                    l-90-90.999C82.331,0.119,75.871-1.185,70.26,1.144c-5.61,2.314-9.258,7.793-9.258,13.857v45h-46\n                    C8.939,60,3.46,63.647,1.146,69.258c-2.329,5.61-1.04,12.056,3.252,16.348l91,90.999c2.813,2.813,6.621,4.395,10.605,4.395h53.789\n                    l85.604,85.604c0.086,0.086,0.203,0.11,0.291,0.194c5.84,5.574,14.711,5.648,20.629,0\n                    C272.548,260.85,272.408,251.56,266.8,245.685z\"\n          />\n        </g>\n      </g>\n      <g>\n        <g>\n          <path\n            d=\"M256.001,0.002c-38.381,0-74.67,9.765-107.348,25.018l46.014,46.014c19.312-6.422,39.895-10.032,61.335-10.032\n                    C363.521,61.001,451,148.481,451,256s-87.479,194.999-194.999,194.999S61.002,363.52,61.002,256\n                    c0-21.44,3.611-42.023,10.032-61.335l-46.014-46.014C9.769,181.33,0.003,217.619,0.003,256\n                    c0,140.609,115.389,255.999,255.998,255.999S512,396.609,512,256S396.612,0.002,256.001,0.002z\"\n          />\n        </g>\n      </g>\n      <g>\n        <g>\n          <path\n            d=\"M256.001,121.001c-15.855,0-30.855,3.25-45,8.293v18.074l34.677,34.677c3.406-0.476,6.788-1.044,10.323-1.044\n                    c41.353,0,75,33.647,75,75c0,41.353-33.647,75-75,75c-41.353,0-75-33.647-75-75c0-3.536,0.568-6.918,1.044-10.323L147.369,211\n                    h-18.074c-5.043,14.145-8.293,29.145-8.293,45c0,74.443,60.557,134.999,134.999,134.999S391.001,330.443,391.001,256\n                    S330.444,121.001,256.001,121.001z\"\n          />\n        </g>\n      </g>\n    </STarget>\n  );\n};\n\nexport default Target;\n","import React from \"react\";\n\nimport Start from \"./svg/Start\";\nimport Target from \"./svg/Target\";\nimport \"./Node.css\";\n\ninterface IProps {\n  onMouseDown: () => void;\n  onMouseEnter: () => void;\n  onMouseUp: () => void;\n  disabled: boolean;\n  isWall: boolean;\n  isStart: boolean;\n  isTarget: boolean;\n  isPath: boolean;\n  isVisited: boolean;\n}\n\nconst Node = ({\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  disabled,\n  isWall,\n  isStart,\n  isTarget,\n  isPath,\n  isVisited,\n}: IProps) => {\n  let className = \"node\";\n  if (isStart) {\n    className = \"node-start\";\n  } else if (isPath) {\n    className = \"node-path\";\n  } else if (isVisited) {\n    className = \"node-visited\";\n  } else if (isTarget) {\n    className = \"node-target\";\n  } else if (isWall) {\n    className = \"node-wall\";\n  }\n\n  return (\n    <td\n      className={className}\n      onMouseDown={\n        disabled\n          ? () => {\n              return;\n            }\n          : onMouseDown\n      }\n      onMouseEnter={\n        disabled\n          ? () => {\n              return;\n            }\n          : onMouseEnter\n      }\n      onMouseUp={\n        disabled\n          ? () => {\n              return;\n            }\n          : onMouseUp\n      }\n    >\n      {isTarget && <Target fill=\"#ffffff\" />}\n      {isStart && <Start fill=\"#ffffff\" />}\n    </td>\n  );\n};\n\nexport default Node;\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nimport aStar from \"../algorithms/aStar\";\nimport randomMaze from \"../algorithms/randomMaze\";\nimport recursiveMaze, { walls } from \"../algorithms/recursiveMaze\";\nimport { INode } from \"../types\";\nimport Button from \"./Button\";\nimport Dropdown from \"./Dropdown\";\nimport Node from \"./Node\";\n\nconst GRID_COLS = 41;\nconst GRID_ROWS = 21;\n\nconst INIT_START_NODE = {\n  rowIdx: 9,\n  colIdx: 3,\n  isWall: false,\n  isStart: true,\n  isTarget: false,\n  g: 0,\n  h: 0,\n  f: 0,\n  parent: undefined,\n  isPath: false,\n  isVisited: false,\n};\n\nconst INIT_TARGET_NODE = {\n  rowIdx: 9,\n  colIdx: 36,\n  isWall: false,\n  isStart: false,\n  isTarget: true,\n  g: 0,\n  h: 0,\n  f: 0,\n  parent: undefined,\n  isPath: false,\n  isVisited: false,\n};\n\nconst SButtonWrapper = styled.div`\n  align-items: center;\n  margin-bottom: 20px;\n  display: flex;\n  justify-content: space-evenly;\n  width: 800px;\n`;\n\nconst SNoPathText = styled.div`\n  color: #5628df;\n  font-weight: 500;\n  margin-bottom: 20px;\n`;\n\nconst SGrid = styled.table`\n  border-collapse: separate;\n  border-spacing: 0px;\n  border-left: 1px solid #c1c1c1;\n  border-top: 1px solid #c1c1c1;\n  font-family: auto;\n`;\n\nconst Pathfinder = () => {\n  const [startNode, setStartNode] = React.useState<INode>(INIT_START_NODE);\n  const [targetNode, setTargetNode] = React.useState<INode>(INIT_TARGET_NODE);\n  const [grid, setGrid] = React.useState<INode[][]>(\n    getInitialGrid(GRID_COLS, GRID_ROWS, INIT_START_NODE, INIT_TARGET_NODE)\n  );\n  const [mouseDown, setMouseDown] = React.useState<boolean>(false);\n  const [movingStart, setMovingStart] = React.useState<boolean>(false);\n  const [movingTarget, setMovingTarget] = React.useState<boolean>(false);\n  const [noValidPath, setNoValidPath] = React.useState<boolean>(false);\n  const [animating, setAnimating] = React.useState<boolean>(false);\n  const [callRecMaze, setCallRecMaze] = React.useState<boolean>(false);\n  const [mazeType, setMazeType] = React.useState<string>(\"Recursive\");\n  const [algoType, setAlgoType] = React.useState<string>(\"A*\");\n\n  const handleMouseDown = (\n    rowIdx: number,\n    colIdx: number,\n    start: boolean,\n    target: boolean\n  ) => {\n    if (start) {\n      setMovingStart(true);\n    } else if (target) {\n      setMovingTarget(true);\n    } else {\n      const newGrid = clearGrid(grid, false);\n      newGrid[rowIdx][colIdx].isWall = !newGrid[rowIdx][colIdx].isWall;\n\n      setGrid([...newGrid]);\n    }\n    setMouseDown(true);\n  };\n\n  const handleMouseEnter = (\n    rowIdx: number,\n    colIdx: number,\n    start: boolean,\n    target: boolean\n  ) => {\n    if (mouseDown) {\n      const newGrid = clearGrid(grid, false);\n      if (movingStart) {\n        for (const row of newGrid) {\n          for (const node of row) {\n            if (!target) {\n              if (node.rowIdx === rowIdx && node.colIdx === colIdx) {\n                node.isStart = true;\n                setStartNode(node);\n              } else {\n                node.isStart = false;\n              }\n            }\n          }\n        }\n        setGrid([...newGrid]);\n      } else if (movingTarget) {\n        for (const row of newGrid) {\n          for (const node of row) {\n            if (!start) {\n              if (node.rowIdx === rowIdx && node.colIdx === colIdx) {\n                node.isTarget = true;\n                setTargetNode(node);\n              } else {\n                node.isTarget = false;\n              }\n            }\n          }\n        }\n        setGrid([...newGrid]);\n      } else {\n        if (\n          !(startNode.rowIdx === rowIdx && startNode.colIdx === colIdx) ||\n          !(targetNode.rowIdx === rowIdx && targetNode.colIdx === colIdx)\n        ) {\n          newGrid[rowIdx][colIdx].isWall = true;\n\n          setGrid([...newGrid]);\n        }\n      }\n    }\n  };\n\n  const handleMouseUp = () => {\n    setMouseDown(false);\n    setMovingStart(false);\n    setMovingTarget(false);\n  };\n\n  const timer = (delay: number) => {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n  };\n\n  const handleAStar = async () => {\n    const { path, closedNodes } = aStar(grid, startNode, targetNode);\n    if (path && closedNodes) {\n      setAnimating(true);\n      setNoValidPath(false);\n      const newGrid = clearGrid(grid, false);\n\n      for (const closedNode of closedNodes) {\n        newGrid[closedNode.rowIdx][closedNode.colIdx].isVisited = true;\n        setGrid([...newGrid]);\n        await timer(50);\n      }\n\n      for (const node of path) {\n        newGrid[node.rowIdx][node.colIdx].isPath = true;\n        setGrid([...newGrid]);\n        await timer(50);\n      }\n      setAnimating(false);\n    } else {\n      setNoValidPath(true);\n    }\n  };\n\n  const handleRandomMaze = async () => {\n    setNoValidPath(false);\n    setAnimating(true);\n    const newGrid = clearGrid(grid, true);\n    const walls = randomMaze(startNode, targetNode, GRID_ROWS, GRID_COLS);\n    let count = 1;\n    for (const wall of walls) {\n      count += 1;\n      newGrid[wall[0]][wall[1]].isWall = true;\n      if (count % 2 === 0 || count === walls.length) {\n        setGrid([...newGrid]);\n        await timer(50);\n      }\n    }\n    setAnimating(false);\n  };\n\n  const handleRecursiveMaze = async () => {\n    await timer(3);\n    setCallRecMaze(true);\n    setNoValidPath(false);\n    setAnimating(true);\n    const newGrid = clearGrid(grid, true);\n    if (walls.length > 0) {\n      let count = 1;\n      for (const wall of walls) {\n        count += 1;\n        const [r, c] = wall.split(\".\");\n        const row = parseInt(r);\n        const col = parseInt(c);\n        newGrid[row][col].isWall = true;\n        if (count % 3 === 0 || count === walls.length) {\n          setGrid([...newGrid]);\n          await timer(50);\n        }\n      }\n    }\n    walls.splice(0, walls.length);\n    setAnimating(false);\n    setCallRecMaze(false);\n  };\n\n  React.useEffect(() => {\n    if (callRecMaze) {\n      const newGrid = clearGrid(grid, true);\n      recursiveMaze(newGrid, startNode.rowIdx, startNode.colIdx, true);\n    }\n  }, [recursiveMaze, callRecMaze, clearGrid]);\n\n  const handleResetGrid = () => {\n    setStartNode(INIT_START_NODE);\n    setTargetNode(INIT_TARGET_NODE);\n    setGrid(\n      getInitialGrid(GRID_COLS, GRID_ROWS, INIT_START_NODE, INIT_TARGET_NODE)\n    );\n    setNoValidPath(false);\n    setAnimating(false);\n  };\n\n  return (\n    <>\n      <SButtonWrapper>\n        <Dropdown\n          label=\"Maze type\"\n          options={[\"Random\", \"Recursive\"]}\n          selectedOption={mazeType}\n          setSelectedOption={setMazeType}\n          onClick={\n            mazeType === \"Random\" ? handleRandomMaze : handleRecursiveMaze\n          }\n          disabled={animating}\n        />\n        <Dropdown\n          label=\"Algorithm\"\n          options={[\"A*\"]}\n          selectedOption={algoType}\n          setSelectedOption={setAlgoType}\n          onClick={handleAStar}\n          disabled={animating}\n        />\n        <Button disabled={animating} onClick={handleResetGrid}>\n          Reset Grid\n        </Button>\n      </SButtonWrapper>\n      {noValidPath && <SNoPathText>No valid path found</SNoPathText>}\n      <SGrid>\n        <tbody>\n          {grid.map((row, rowIdx) => (\n            <tr key={rowIdx}>\n              {row.map((node, nodeIdx) => (\n                <Node\n                  key={`${rowIdx}${nodeIdx}`}\n                  onMouseDown={() =>\n                    handleMouseDown(\n                      node.rowIdx,\n                      node.colIdx,\n                      node.isStart,\n                      node.isTarget\n                    )\n                  }\n                  onMouseEnter={() =>\n                    handleMouseEnter(\n                      node.rowIdx,\n                      node.colIdx,\n                      node.isStart,\n                      node.isTarget\n                    )\n                  }\n                  onMouseUp={handleMouseUp}\n                  disabled={animating}\n                  isWall={node.isWall}\n                  isStart={node.isStart}\n                  isTarget={node.isTarget}\n                  isPath={node.isPath}\n                  isVisited={node.isVisited}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </SGrid>\n    </>\n  );\n};\n\nconst getInitialGrid = (\n  columns: number,\n  rows: number,\n  startPosition: { rowIdx: number; colIdx: number },\n  targetPosition: { rowIdx: number; colIdx: number }\n) => {\n  const grid = [];\n  for (let row = 0; row < rows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < columns; col++) {\n      currentRow.push(createNode(col, row, startPosition, targetPosition));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (\n  colIdx: number,\n  rowIdx: number,\n  startPosition: { rowIdx: number; colIdx: number },\n  targetPosition: { rowIdx: number; colIdx: number }\n) => {\n  return {\n    colIdx,\n    rowIdx,\n    isWall: false,\n    isStart: rowIdx === startPosition.rowIdx && colIdx === startPosition.colIdx,\n    isTarget:\n      rowIdx === targetPosition.rowIdx && colIdx === targetPosition.colIdx,\n    g: 0,\n    h: 0,\n    f: 0,\n    parent: undefined,\n    isPath: false,\n    isVisited: false,\n  };\n};\n\nconst clearGrid = (grid: INode[][], includeWalls: boolean) => {\n  const newGrid = grid;\n  for (const row of newGrid) {\n    for (const node of row) {\n      if (includeWalls && node.isWall) {\n        newGrid[node.rowIdx][node.colIdx].isWall = false;\n      }\n      newGrid[node.rowIdx][node.colIdx].isPath = false;\n      newGrid[node.rowIdx][node.colIdx].isVisited = false;\n    }\n  }\n\n  return newGrid;\n};\n\nexport default Pathfinder;\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nimport Pathfinder from \"./components/Pathfinder\";\n\nconst SContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  padding: 30px;\n`;\n\nconst SHeader = styled.h1`\n  line-height: 1;\n  margin-bottom: 20px;\n`;\n\nconst SDescription = styled.p`\n  color: #6b6c73;\n  font-family: \"Poppins\", sans-serif;\n  margin-bottom: 20px;\n  margin-top: 0;\n`;\n\nconst App = () => {\n  return (\n    <SContainer>\n      <SHeader>Pathfinder Visualiser</SHeader>\n      <SDescription>\n        Visualise algorithms that calculate the shortest path between two\n        points.\n      </SDescription>\n      <Pathfinder />\n    </SContainer>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}